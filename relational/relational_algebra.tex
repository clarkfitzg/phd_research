% A simple template for LaTeX documents
% 
% To produce pdf run:
%   $ pdflatex paper.tex 
%


\documentclass[12pt]{article}

% Begin paragraphs with new line
\usepackage{parskip}  

% Change margin size
\usepackage[margin=1in]{geometry}   

% Graphics Example:  (PDF's make for good plots)
\usepackage{graphicx}               
% \centerline{\includegraphics{figure.pdf}}

% subfigures, side by side
\usepackage{subcaption}

% hyperlinks
\usepackage{hyperref}

% Blocks of code
\usepackage{listings}
\lstset{basicstyle=\ttfamily, title=\lstname}
% Insert code like this. replace `plot.R` with file name.
% \lstinputlisting{plot.R}

% Monospaced fonts
%\usepackage{inconsolata}
% GNU \texttt{make} is a nice tool.

% Supports proof environment
\usepackage{amsthm}

% Allows writing \implies and align*
\usepackage{amsmath}

% Allows mathbb{R}
\usepackage{amsfonts}

% Numbers in scientific notation
% \usepackage{siunitx}

% Use tables generated by pandas
\usepackage{booktabs}

% Allows umlaut and non ascii characters
\usepackage[utf8]{inputenc}

% norm and infinity norm
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\newcommand{\inorm}[1]{\left\lVert#1\right\rVert_\infty}

% Statistics essentials
\newcommand{\iid}{\text{ iid }}
\newcommand{\Exp}{\operatorname{E}}
\newcommand{\Var}{\operatorname{Var}}
\newcommand{\Cov}{\operatorname{Cov}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\title{Relational Algebra and R}
\date{\today}
\author{Clark Fitzgerald}
\maketitle

Points to make:

There's a large overlap between many languages / systems to express the
same semantics. For example base R, dplyr, data.table, and SQL.
On the one hand this is fine- different packages compete for users and
drive progress, ie. I've heard beginners say that they appreciate the
consistency and mental model of dplyr.  On the other hand, if they're doing
the same thing then there's redundancy here.  Why not share implementation?
We should use the fastest one available, especially for large data sets.

I see all these big highly engineered data processing systems
from Apache: Hive, Spark, Cassandra, etc. Then there's R, which is
expressive and fast on data that fits in memory on a single machine.
I'm interested in having the best of both worlds. I want the expressiveness
of R code and the scale of these big systems.

Most academic researchers don't have the opportunity to work with
these kinds of large systems. It often takes significant effort to
configure and maintain them, and it's probably not worth it unless you're
analyzing TB of data.


The other motivation to put it in a standard form is to 

\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Wed Mar  7 09:37:11 PST 2018

Thinking about translating R into relational algebra.
This abstracts R code into a semantic representation with some well
developed theory behind it.

In relational algebras the domain is tables. The differences between an R
data frame and a table in relational algebra are:

\begin{enumerate}
    \item R data frame has ordered columns and rows (unlike SQL)
    \item R data frame allows duplicate rows (like most SQL implementations)
\end{enumerate}

To do symbolic manipulation of code we really need some kind of algebra.
Otherwise everything is ad hoc rules.



\begin{table}[]
\centering
    \caption{Correspondence between R data frame functions and relational
    algebra}
\label{tab-correspond}
\begin{tabular}{lll}
    \textbf{operation} & \textbf{relational algebra} & \textbf{R language}
    \\
\hline
    \\ union  & $\bigcup_{i=1}^n D_i$
        & \texttt{rbind(D1, ..., Dn)}
    \\ cartesian product   & $D \times E$
        & \texttt{merge(D, E, by = c())}
    \\ project & $\Pi _{a_{1},\ldots ,a_{n}}(D)$
        & \texttt{D[, c("a1", ..., "an")]}
    \\ selection / propositional logic & $\sigma_{a < 20} (D)$
        & \texttt{subset(D, a < 20)}
    \\ rename & $\rho_{a / b}(R)$
        & \texttt{colnames(D)[colnames(D) == "a"] <- "b"}
    \\ natural join & $D \Join E$
        & \texttt{merge(D, E)}
\end{tabular}
\end{table}

R gives us a parser. How can we walk over that parse tree to build up the
relational algebra? Here's an R expression: 
\verb$subset(D, a < 20 & b < 30, c("a", "b", "c"))$.
The corresponding relational algebra is $\sigma_{a < 20 \wedge b < 30} \Pi _{a,
b, c} (D)$. The subset function uses nonstandard evaluation which allows us
to directly map R predicate logic into that of relational algebra. But
there could be one or more levels of indirection, ie $a < e$ for some
variable $e$. $e$ could be a literal, ie $e = 3$, or it could be computed
dynamically. In this dynamic case we may be able to still optimize things
once $e$ becomes known.

Cite sqldf, relation and rquery packages


\section{Filtering at the source}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\end{document}
